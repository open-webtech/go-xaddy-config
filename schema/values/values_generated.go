package values

import (
	"fmt"
	"strconv"
)

// This file is autogenerated using "go generate ./schema/values". Do not modify, your changes will be lost.

// -- bool Value
type BoolValue struct{ v *bool }

// NewBoolValue creates a new BoolValue
func NewBoolValue(p *bool) *BoolValue {
	return &BoolValue{p}
}

// Set sets the value of the BoolValue
func (d *BoolValue) Set(s string) error {
	v, err := strconv.ParseBool(s)
	if err == nil {
		*d.v = (bool)(v)
	}
	return err
}

// Get returns the value of the BoolValue
func (d *BoolValue) Get() interface{} { return (bool)(*d.v) }

// String returns a string representation of the BoolValue
func (d *BoolValue) String() string { return fmt.Sprintf("%v", *d.v) }

// BoolsValue accumulates bool values into a slice.
func NewBoolsValue(target *[]bool) Value {
	return NewAccumulator(target, func(v interface{}) Value {
		return NewBoolValue(v.(*bool))
	})
}

/*func BoolsArg(target *[]bool, attributes ...args.ArgAttribute) *args.ArgDef {
	return args.NewArgDef(NewAccumulator(target, func(v interface{}) Value {
		return NewBoolValue(v.(*bool))
	}), args.Bool, attributes...)
}*/

// -- string Value
type StringValue struct{ v *string }

// NewStringValue creates a new StringValue
func NewStringValue(p *string) *StringValue {
	return &StringValue{p}
}

// Set sets the value of the StringValue
func (d *StringValue) Set(s string) error {
	v, err := s, error(nil)
	if err == nil {
		*d.v = (string)(v)
	}
	return err
}

// Get returns the value of the StringValue
func (d *StringValue) Get() interface{} { return (string)(*d.v) }

// String returns a string representation of the StringValue
func (d *StringValue) String() string { return string(*d.v) }

// StringsValue accumulates string values into a slice.
func NewStringsValue(target *[]string) Value {
	return NewAccumulator(target, func(v interface{}) Value {
		return NewStringValue(v.(*string))
	})
}

/*func StringsArg(target *[]string, attributes ...args.ArgAttribute) *args.ArgDef {
	return args.NewArgDef(NewAccumulator(target, func(v interface{}) Value {
		return NewStringValue(v.(*string))
	}), args.String, attributes...)
}*/

// -- uint Value
type UintValue struct{ v *uint }

// NewUintValue creates a new UintValue
func NewUintValue(p *uint) *UintValue {
	return &UintValue{p}
}

// Set sets the value of the UintValue
func (d *UintValue) Set(s string) error {
	v, err := strconv.ParseUint(s, 0, 64)
	if err == nil {
		*d.v = (uint)(v)
	}
	return err
}

// Get returns the value of the UintValue
func (d *UintValue) Get() interface{} { return (uint)(*d.v) }

// String returns a string representation of the UintValue
func (d *UintValue) String() string { return fmt.Sprintf("%v", *d.v) }

// UintsValue accumulates uint values into a slice.
func NewUintsValue(target *[]uint) Value {
	return NewAccumulator(target, func(v interface{}) Value {
		return NewUintValue(v.(*uint))
	})
}

/*func UintsArg(target *[]uint, attributes ...args.ArgAttribute) *args.ArgDef {
	return args.NewArgDef(NewAccumulator(target, func(v interface{}) Value {
		return NewUintValue(v.(*uint))
	}), args.Uint, attributes...)
}*/

// -- uint8 Value
type Uint8Value struct{ v *uint8 }

// NewUint8Value creates a new Uint8Value
func NewUint8Value(p *uint8) *Uint8Value {
	return &Uint8Value{p}
}

// Set sets the value of the Uint8Value
func (d *Uint8Value) Set(s string) error {
	v, err := strconv.ParseUint(s, 0, 8)
	if err == nil {
		*d.v = (uint8)(v)
	}
	return err
}

// Get returns the value of the Uint8Value
func (d *Uint8Value) Get() interface{} { return (uint8)(*d.v) }

// String returns a string representation of the Uint8Value
func (d *Uint8Value) String() string { return fmt.Sprintf("%v", *d.v) }

// Uint8ListValue accumulates uint8 values into a slice.
func NewUint8ListValue(target *[]uint8) Value {
	return NewAccumulator(target, func(v interface{}) Value {
		return NewUint8Value(v.(*uint8))
	})
}

/*func Uint8ListArg(target *[]uint8, attributes ...args.ArgAttribute) *args.ArgDef {
	return args.NewArgDef(NewAccumulator(target, func(v interface{}) Value {
		return NewUint8Value(v.(*uint8))
	}), args.Uint8, attributes...)
}*/

// -- uint16 Value
type Uint16Value struct{ v *uint16 }

// NewUint16Value creates a new Uint16Value
func NewUint16Value(p *uint16) *Uint16Value {
	return &Uint16Value{p}
}

// Set sets the value of the Uint16Value
func (d *Uint16Value) Set(s string) error {
	v, err := strconv.ParseUint(s, 0, 16)
	if err == nil {
		*d.v = (uint16)(v)
	}
	return err
}

// Get returns the value of the Uint16Value
func (d *Uint16Value) Get() interface{} { return (uint16)(*d.v) }

// String returns a string representation of the Uint16Value
func (d *Uint16Value) String() string { return fmt.Sprintf("%v", *d.v) }

// Uint16ListValue accumulates uint16 values into a slice.
func NewUint16ListValue(target *[]uint16) Value {
	return NewAccumulator(target, func(v interface{}) Value {
		return NewUint16Value(v.(*uint16))
	})
}

/*func Uint16ListArg(target *[]uint16, attributes ...args.ArgAttribute) *args.ArgDef {
	return args.NewArgDef(NewAccumulator(target, func(v interface{}) Value {
		return NewUint16Value(v.(*uint16))
	}), args.Uint16, attributes...)
}*/

// -- uint32 Value
type Uint32Value struct{ v *uint32 }

// NewUint32Value creates a new Uint32Value
func NewUint32Value(p *uint32) *Uint32Value {
	return &Uint32Value{p}
}

// Set sets the value of the Uint32Value
func (d *Uint32Value) Set(s string) error {
	v, err := strconv.ParseUint(s, 0, 32)
	if err == nil {
		*d.v = (uint32)(v)
	}
	return err
}

// Get returns the value of the Uint32Value
func (d *Uint32Value) Get() interface{} { return (uint32)(*d.v) }

// String returns a string representation of the Uint32Value
func (d *Uint32Value) String() string { return fmt.Sprintf("%v", *d.v) }

// Uint32ListValue accumulates uint32 values into a slice.
func NewUint32ListValue(target *[]uint32) Value {
	return NewAccumulator(target, func(v interface{}) Value {
		return NewUint32Value(v.(*uint32))
	})
}

/*func Uint32ListArg(target *[]uint32, attributes ...args.ArgAttribute) *args.ArgDef {
	return args.NewArgDef(NewAccumulator(target, func(v interface{}) Value {
		return NewUint32Value(v.(*uint32))
	}), args.Uint32, attributes...)
}*/

// -- uint64 Value
type Uint64Value struct{ v *uint64 }

// NewUint64Value creates a new Uint64Value
func NewUint64Value(p *uint64) *Uint64Value {
	return &Uint64Value{p}
}

// Set sets the value of the Uint64Value
func (d *Uint64Value) Set(s string) error {
	v, err := strconv.ParseUint(s, 0, 64)
	if err == nil {
		*d.v = (uint64)(v)
	}
	return err
}

// Get returns the value of the Uint64Value
func (d *Uint64Value) Get() interface{} { return (uint64)(*d.v) }

// String returns a string representation of the Uint64Value
func (d *Uint64Value) String() string { return fmt.Sprintf("%v", *d.v) }

// Uint64ListValue accumulates uint64 values into a slice.
func NewUint64ListValue(target *[]uint64) Value {
	return NewAccumulator(target, func(v interface{}) Value {
		return NewUint64Value(v.(*uint64))
	})
}

/*func Uint64ListArg(target *[]uint64, attributes ...args.ArgAttribute) *args.ArgDef {
	return args.NewArgDef(NewAccumulator(target, func(v interface{}) Value {
		return NewUint64Value(v.(*uint64))
	}), args.Uint64, attributes...)
}*/

// -- int Value
type IntValue struct{ v *int }

// NewIntValue creates a new IntValue
func NewIntValue(p *int) *IntValue {
	return &IntValue{p}
}

// Set sets the value of the IntValue
func (d *IntValue) Set(s string) error {
	v, err := strconv.ParseFloat(s, 64)
	if err == nil {
		*d.v = (int)(v)
	}
	return err
}

// Get returns the value of the IntValue
func (d *IntValue) Get() interface{} { return (int)(*d.v) }

// String returns a string representation of the IntValue
func (d *IntValue) String() string { return fmt.Sprintf("%v", *d.v) }

// IntsValue accumulates int values into a slice.
func NewIntsValue(target *[]int) Value {
	return NewAccumulator(target, func(v interface{}) Value {
		return NewIntValue(v.(*int))
	})
}

/*func IntsArg(target *[]int, attributes ...args.ArgAttribute) *args.ArgDef {
	return args.NewArgDef(NewAccumulator(target, func(v interface{}) Value {
		return NewIntValue(v.(*int))
	}), args.Int, attributes...)
}*/

// -- int8 Value
type Int8Value struct{ v *int8 }

// NewInt8Value creates a new Int8Value
func NewInt8Value(p *int8) *Int8Value {
	return &Int8Value{p}
}

// Set sets the value of the Int8Value
func (d *Int8Value) Set(s string) error {
	v, err := strconv.ParseInt(s, 0, 8)
	if err == nil {
		*d.v = (int8)(v)
	}
	return err
}

// Get returns the value of the Int8Value
func (d *Int8Value) Get() interface{} { return (int8)(*d.v) }

// String returns a string representation of the Int8Value
func (d *Int8Value) String() string { return fmt.Sprintf("%v", *d.v) }

// Int8ListValue accumulates int8 values into a slice.
func NewInt8ListValue(target *[]int8) Value {
	return NewAccumulator(target, func(v interface{}) Value {
		return NewInt8Value(v.(*int8))
	})
}

/*func Int8ListArg(target *[]int8, attributes ...args.ArgAttribute) *args.ArgDef {
	return args.NewArgDef(NewAccumulator(target, func(v interface{}) Value {
		return NewInt8Value(v.(*int8))
	}), args.Int8, attributes...)
}*/

// -- int16 Value
type Int16Value struct{ v *int16 }

// NewInt16Value creates a new Int16Value
func NewInt16Value(p *int16) *Int16Value {
	return &Int16Value{p}
}

// Set sets the value of the Int16Value
func (d *Int16Value) Set(s string) error {
	v, err := strconv.ParseInt(s, 0, 16)
	if err == nil {
		*d.v = (int16)(v)
	}
	return err
}

// Get returns the value of the Int16Value
func (d *Int16Value) Get() interface{} { return (int16)(*d.v) }

// String returns a string representation of the Int16Value
func (d *Int16Value) String() string { return fmt.Sprintf("%v", *d.v) }

// Int16ListValue accumulates int16 values into a slice.
func NewInt16ListValue(target *[]int16) Value {
	return NewAccumulator(target, func(v interface{}) Value {
		return NewInt16Value(v.(*int16))
	})
}

/*func Int16ListArg(target *[]int16, attributes ...args.ArgAttribute) *args.ArgDef {
	return args.NewArgDef(NewAccumulator(target, func(v interface{}) Value {
		return NewInt16Value(v.(*int16))
	}), args.Int16, attributes...)
}*/

// -- int32 Value
type Int32Value struct{ v *int32 }

// NewInt32Value creates a new Int32Value
func NewInt32Value(p *int32) *Int32Value {
	return &Int32Value{p}
}

// Set sets the value of the Int32Value
func (d *Int32Value) Set(s string) error {
	v, err := strconv.ParseInt(s, 0, 32)
	if err == nil {
		*d.v = (int32)(v)
	}
	return err
}

// Get returns the value of the Int32Value
func (d *Int32Value) Get() interface{} { return (int32)(*d.v) }

// String returns a string representation of the Int32Value
func (d *Int32Value) String() string { return fmt.Sprintf("%v", *d.v) }

// Int32ListValue accumulates int32 values into a slice.
func NewInt32ListValue(target *[]int32) Value {
	return NewAccumulator(target, func(v interface{}) Value {
		return NewInt32Value(v.(*int32))
	})
}

/*func Int32ListArg(target *[]int32, attributes ...args.ArgAttribute) *args.ArgDef {
	return args.NewArgDef(NewAccumulator(target, func(v interface{}) Value {
		return NewInt32Value(v.(*int32))
	}), args.Int32, attributes...)
}*/

// -- int64 Value
type Int64Value struct{ v *int64 }

// NewInt64Value creates a new Int64Value
func NewInt64Value(p *int64) *Int64Value {
	return &Int64Value{p}
}

// Set sets the value of the Int64Value
func (d *Int64Value) Set(s string) error {
	v, err := strconv.ParseInt(s, 0, 64)
	if err == nil {
		*d.v = (int64)(v)
	}
	return err
}

// Get returns the value of the Int64Value
func (d *Int64Value) Get() interface{} { return (int64)(*d.v) }

// String returns a string representation of the Int64Value
func (d *Int64Value) String() string { return fmt.Sprintf("%v", *d.v) }

// Int64ListValue accumulates int64 values into a slice.
func NewInt64ListValue(target *[]int64) Value {
	return NewAccumulator(target, func(v interface{}) Value {
		return NewInt64Value(v.(*int64))
	})
}

/*func Int64ListArg(target *[]int64, attributes ...args.ArgAttribute) *args.ArgDef {
	return args.NewArgDef(NewAccumulator(target, func(v interface{}) Value {
		return NewInt64Value(v.(*int64))
	}), args.Int64, attributes...)
}*/

// -- float32 Value
type Float32Value struct{ v *float32 }

// NewFloat32Value creates a new Float32Value
func NewFloat32Value(p *float32) *Float32Value {
	return &Float32Value{p}
}

// Set sets the value of the Float32Value
func (d *Float32Value) Set(s string) error {
	v, err := strconv.ParseFloat(s, 32)
	if err == nil {
		*d.v = (float32)(v)
	}
	return err
}

// Get returns the value of the Float32Value
func (d *Float32Value) Get() interface{} { return (float32)(*d.v) }

// String returns a string representation of the Float32Value
func (d *Float32Value) String() string { return fmt.Sprintf("%v", *d.v) }

// Float32ListValue accumulates float32 values into a slice.
func NewFloat32ListValue(target *[]float32) Value {
	return NewAccumulator(target, func(v interface{}) Value {
		return NewFloat32Value(v.(*float32))
	})
}

/*func Float32ListArg(target *[]float32, attributes ...args.ArgAttribute) *args.ArgDef {
	return args.NewArgDef(NewAccumulator(target, func(v interface{}) Value {
		return NewFloat32Value(v.(*float32))
	}), args.Float32, attributes...)
}*/

// -- float64 Value
type Float64Value struct{ v *float64 }

// NewFloat64Value creates a new Float64Value
func NewFloat64Value(p *float64) *Float64Value {
	return &Float64Value{p}
}

// Set sets the value of the Float64Value
func (d *Float64Value) Set(s string) error {
	v, err := strconv.ParseFloat(s, 64)
	if err == nil {
		*d.v = (float64)(v)
	}
	return err
}

// Get returns the value of the Float64Value
func (d *Float64Value) Get() interface{} { return (float64)(*d.v) }

// String returns a string representation of the Float64Value
func (d *Float64Value) String() string { return fmt.Sprintf("%v", *d.v) }

// Float64ListValue accumulates float64 values into a slice.
func NewFloat64ListValue(target *[]float64) Value {
	return NewAccumulator(target, func(v interface{}) Value {
		return NewFloat64Value(v.(*float64))
	})
}

/*func Float64ListArg(target *[]float64, attributes ...args.ArgAttribute) *args.ArgDef {
	return args.NewArgDef(NewAccumulator(target, func(v interface{}) Value {
		return NewFloat64Value(v.(*float64))
	}), args.Float64, attributes...)
}*/
