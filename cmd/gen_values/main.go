package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"strings"
	"text/template"

	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

const (
	tmplValues = `package {{Pkg.Name}}

// This file is autogenerated using "go generate ./{{Pkg.Path}}". Do not modify, your changes will be lost.

{{range .}}
{{if not .NoValueParser}}
// -- {{.Type}} Value
type {{.|ValueName}} struct { v *{{.Type}} }

// New{{.|ValueName}} creates a new {{.|ValueName}}
func New{{.|ValueName}}(p *{{.Type}}) *{{.|ValueName}} {
	return &{{.|ValueName}}{p}
}

// Set sets the value of the {{.|ValueName}}
func (d *{{.|ValueName}}) Set(s string) error {
	v, err := {{.Parser}}
	if err == nil {
		*d.v = ({{.Type}})(v)
	}
	return err
}

// Get returns the value of the {{.|ValueName}}
func (d *{{.|ValueName}}) Get() interface{} { return ({{.Type}})(*d.v) }

// String returns a string representation of the {{.|ValueName}}
func (d *{{.|ValueName}}) String() string { return {{.|Format}} }
{{end}}
// {{.|Plural}}Value accumulates {{.Type}} values into a slice.
func New{{.|Plural}}Value(target *[]{{.Type}}) Value {
	return NewAccumulator(target, func(v interface{}) Value {
		return New{{.|ValueName}}(v.(*{{.Type}}))
	})
}

/*func {{.|Plural}}Arg(target *[]{{.Type}}, attributes ...args.ArgAttribute) *args.ArgDef {
	return args.NewArgDef(NewAccumulator(target, func(v interface{}) Value {
		return New{{.|ValueName}}(v.(*{{.Type}}))
	}), args.{{.|Name}}, attributes...)
}*/

{{end}}
`
	tmplArgs = `package {{Pkg.Name}}

// This file is autogenerated using "go generate ./{{Pkg.Path}}". Do not modify, your changes will be lost.

const (
{{- range $i, $_ := .}}{{if and .Basic (not .NoValueParser)}}
	{{.|Name}}{{if eq $i 0}} ValueType = iota{{end}}
{{- end}}{{end}}
)

{{range .}}{{if and .Basic (not .NoValueParser)}}
func {{.|Name}}Arg(target *{{.Type}}, attributes ...ArgAttribute) *ArgDef {
	return NewArgDef(values.New{{.|ValueName}}(target), {{.|Name}}, attributes...)
}

func Variadic{{.|Name}}Arg(target *[]{{.Type}}, attributes ...ArgAttribute) *ArgDef {
	return NewVariadicArgDef(values.New{{.|PluralValueName}}(target), {{.|Name}}, attributes...)
}
{{end}}{{end}}
`
)

type Value struct {
	Name          string `json:"name"`
	Basic         bool   `json:"basic"`
	NoValueParser bool   `json:"no_value_parser"`
	Type          string `json:"type"`
	Parser        string `json:"parser"`
	Format        string `json:"format"`
	Plural        string `json:"plural"`
	Help          string `json:"help"`
}

type Package struct {
	PathParts []string
}

func InitPackage(path string) Package {
	return Package{strings.Split(path, "/")}
}

func (p Package) Path() string {
	return strings.Join(p.PathParts, "/")
}

func (p Package) Name() string {
	return p.PathParts[len(p.PathParts)-1]
}

func fatalIfError(err error) {
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func main() {
	var pkg string
	flag.StringVar(&pkg, "pkg", "values", "package name")
	flag.Parse()

	var err error
	switch pkg {
	case "args":
		err = render(tmplArgs, "args_generated.go", InitPackage("schema/args"))
	case "values":
		err = render(tmplValues, "values_generated.go", InitPackage("schema/values"))
	default:
		err = fmt.Errorf("unknown package %q", pkg)
	}

	fatalIfError(err)
}

func render(stmpl, outputFile string, pkg Package) error {
	return renderWithValuesFile(stmpl, outputFile, pkg, "../values/values.json")
}

func renderWithValuesFile(stmpl, outputFile string, pkg Package, valuesFile string) error {
	r, err := os.Open(valuesFile)
	if err != nil {
		return err
	}
	defer r.Close()

	v := []Value{}
	err = json.NewDecoder(r).Decode(&v)
	if err != nil {
		return err
	}

	typeName := func(v *Value) string {
		if v.Name != "" {
			return v.Name
		}
		return cases.Title(language.English).String(v.Type)
	}
	plural := func(v *Value) string {
		if v.Plural != "" {
			return v.Plural
		}
		return typeName(v) + "List"
	}

	t, err := template.New(outputFile).Funcs(template.FuncMap{
		"Pkg": func() Package {
			return pkg
		},
		"Lower": strings.ToLower,
		"Format": func(v *Value) string {
			if v.Format != "" {
				return v.Format
			}
			return "fmt.Sprintf(\"%v\", *d.v)"
		},
		"Name": typeName,
		"ValueName": func(v *Value) string {
			return typeName(v) + "Value"
		},
		"Plural": plural,
		"PluralValueName": func(v *Value) string {
			return plural(v) + "Value"
		},
	}).Parse(stmpl)
	if err != nil {
		return err
	}

	w, err := os.Create(outputFile)
	if err != nil {
		return err
	}
	defer w.Close()

	if err = t.Execute(w, v); err != nil {
		return err
	}

	// Run goimports if available
	if _, err := exec.LookPath("goimports"); err != nil {
		fmt.Fprintf(os.Stderr, "warning: goimports not found, skipping formatting\n")
		return nil
	}

	return exec.Command("goimports", "-w", outputFile).Run()
}
